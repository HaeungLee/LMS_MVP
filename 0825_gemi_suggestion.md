# Gemini 제안: LMS MVP 개선 방안 (2025-08-25)

안녕하세요! 현재 진행 중인 LMS MVP 프로젝트의 코드베이스를 분석했으며, 이를 바탕으로 더 안정적이고 확장성 있는 애플리케이션으로 발전시키기 위한 몇 가지 개선점을 제안합니다.

## 종합 분석 및 개선 제안

### 1. 테스트 프레임워크 부재 (가장 시급)

*   **현황:** `backend/requirements.txt` 와 `frontend/package.json` 어디에도 `pytest`, `jest`, `vitest` 와 같은 테스트 프레임워크가 포함되어 있지 않습니다.
*   **문제점:** 새로운 기능 추가나 리팩토링 시 기존 기능이 고장 나지 않았는지 수동으로 확인해야 합니다. 이는 버그 발생 가능성을 높이고 개발 속도를 저하 시킵니다.
*   **제안:**
    *   **백엔드:** `pytest`를 도입하여 API 엔드포인트와 비즈니스 로직에 대한 테스트를 자동화하는 것을 추천합니다.
    *   **프론트엔드:** Vite 환경과 잘 통합되는 `vitest`와 `React Testing Library`를 추가하여 컴포넌트와 사용자 상호작용을 테스트하는 것이 좋습니다.

### 2. 백엔드 보안 강화

*   **현황:** CORS 설정이 `allow_headers=["*"]`로 되어 있어 모든 헤더를 허용하고 있습니다.
*   **문제점:** 필요 이상으로 넓은 범위의 헤더를 허용하면 보안에 취약할 수 있습니다.
*   **제안:** `Content-Type`, `Authorization` 등 실제 애플리케이션에서 사용하는 헤더만 명시적으로 허용하도록 설정을 강화하는 것이 안전합니다.

### 3. 의존성 관리

*   **현황:** `requirements.txt`와 `package.json`의 라이브러리 버전이 `^`나 `>=`로 지정되어 있습니다.
*   **문제점:** 새로운 개발 환경을 구성할 때 의도치 않은 최신 버전이 설치되어 호환성 문제를 일으킬 수 있습니다.
*   **제안:**
    *   **백엔드:** `pip freeze > requirements.txt` 명령을 사용해 현재 설치된 라이브러리의 정확한 버전을 명시하여(pinning) 예기치 않은 변경을 방지하는 것이 좋습니다.
    *   **프론트엔드:** `package-lock.json`이 이미 그 역할을 하고 있으므로, `npm install`을 사용할 때 이 파일이 잘 활용되고 있는지 확인하는 것이 중요합니다.

### 4. 코드 가독성 및 유지보수

*   **현황:** `backend/app/main.py`에서 데이터베이스 테이블을 직접 생성하는 로직이 포함되어 있습니다.
*   **문제점:** 개발 초기에는 편리할 수 있으나, 애플리케이션 시작(bootstrap) 로직과 스키마 관리 로직이 섞여 있어 혼란을 줄 수 있습니다.
*   **제안:** 데이터베이스 스키마는 `Alembic`으로만 관리하고, `main.py`에서는 해당 코드를 제거하여 역할을 명확히 분리하는 것을 추천합니다.

---

## 심층 분석: 비즈니스 로직 및 시스템 구조

핵심 기능(AI 문제 생성, 제출, 채점, 피드백)을 중심으로 시스템 로직을 심층 분석한 결과, 다음과 같은 구체적인 개선 및 보완 사항을 제안합니다.

### 1. API 엔드포인트 및 서비스 로직 결합도

*   **현황:** `ai_learning.py` 파일이 문제 생성, 일일 계획, 학습 추천, 피드백 제출 등 너무 많은 책임을 가지고 있습니다. 특정 엔드포인트는 채점, 피드백, 분석 등 여러 로직을 직접 수행합니다.
*   **문제점:** 기능 확장 시 유지보수가 어렵고 코드 중복 가능성이 높습니다.
*   **제안:**
    *   **단일 책임 원칙(SRP) 적용:** `ai_learning.py`를 `question_generator.py`, `curriculum.py`, `feedback_analysis.py` 등 기능별로 분리합니다.
    *   **서비스 계층 활용 강화:** API 엔드포인트는 요청/응답 처리에 집중하고, 실제 비즈니스 로직은 `scoring_service`, `feedback_service` 등 서비스 계층에 위임하는 구조를 강화합니다.

### 2. 동기/비동기 처리 전략

*   **현황:** 답안 제출(`POST /submit`) 시 모든 채점과 분석이 동기적으로 처리되어 사용자가 오래 대기해야 할 수 있습니다.
*   **문제점:** 특히 여러 문제를 동시에 제출할 때 사용자 경험(UX)이 크게 저하됩니다.
*   **제안:**
    *   **AI 연산의 비동기화:** 시간이 오래 걸리는 AI 피드백 생성, 상세 분석 등은 모두 백그라운드 작업으로 전환합니다.
    *   **추천 워크플로우:**
        1.  **즉시 응답:** 답안 제출 시, 빠른 규칙 기반 채점만 수행하고 "채점 완료, AI 분석 중..."과 같은 중간 결과를 즉시 반환합니다.
        2.  **백그라운드 처리:** AI를 이용한 상세 분석은 백그라운드에서 처리합니다.
        3.  **결과 조회:** 프론트엔드는 폴링(Polling)이나 웹소켓(WebSocket)으로 서버에 분석 완료 여부를 확인하고, 완료 시 최종 결과를 가져와 사용자에게 보여줍니다.

### 3. AI 프롬프트 관리 효율화

*   **현황:** `ai_question_generator.py` 코드 내에 다양한 AI 프롬프트가 하드코딩되어 있습니다.
*   **문제점:** 프롬프트를 수정하고 테스트하기 위해 파이썬 코드를 직접 변경해야 하는 번거로움이 있습니다.
*   **제안:**
    *   **프롬프트 템플릿 파일 분리:** `.txt`나 `.j2`(Jinja2) 같은 별도 템플릿 파일로 프롬프트를 분리하고, 코드에서는 이 템플릿을 동적으로 읽어와 사용합니다. 이를 통해 코드 변경 없이 프롬프트만 쉽게 관리할 수 있습니다.

### 4. 데이터 모델링 및 상태 관리 견고성

*   **현황:** 서버 재시작 시 사라지는 인메모리 딕셔너리(`submission_results_store`, `feedback_cache`)를 DB와 혼용하여 상태를 관리하고 있습니다.
*   **문제점:** 데이터가 유실될 수 있으며, 서버를 여러 대로 확장할 경우 상태 공유가 불가능합니다.
*   **제안:**
    *   **상태의 DB 중앙화:** 모든 제출 및 채점 결과는 DB에 저장하고, `status` 컬럼(예: `pending`, `scoring`, `completed`)을 추가하여 처리 상태를 명확하게 관리합니다.
    *   **전문 캐시 도입:** 인메모리 딕셔너리 대신 `Redis`와 같은 전문 캐시 솔루션을 도입하여 데이터 영속성을 확보하고, 비동기 작업 큐(Celery 등과 연동)의 기반으로 활용하는 것을 강력히 추천합니다.

### 5. 채점 로직 고도화

*   **현황:** `rapidfuzz`와 키워드 매칭, 제한적인 동의어 사전을 기반으로 채점 로직이 구현되어 있습니다.
*   **문제점:** 코드의 논리적 동등성(예: `for`문과 `while`문으로 같은 결과 구현)을 평가하거나, 문맥에 따른 의미 차이를 구별하기 어렵습니다.
*   **제안:**
    *   **AST(Abstract Syntax Tree) 활용:** 파이썬의 `ast` 모듈을 활용해 코드의 구조와 로직을 비교하면, 더 정확한 논리적 유사도 채점이 가능합니다.
    *   **임베딩 기반 유사도 측정:** 주관식 답변의 의미적 유사도를 더 정확하게 측정하기 위해, Sentence Transformers와 같은 사전 학습된 언어 모델을 사용하여 문장 임베딩 벡터 간의 코사인 유사도를 계산하는 방식을 도입할 수 있습니다.